# 移动端图片和文件上传接口说明

## 概述

移动端使用 HTTP POST 请求上传文件，支持实时进度显示。相比 Socket.IO 方式，HTTP 上传具有更好的进度支持，不会阻塞 UI。

## 接口规范

### 1. 上传接口

**接口地址：** `POST {serverHost}/api/upload`

**请求方式：** `POST`

**Content-Type：** `multipart/form-data`

**请求参数（FormData）：**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| file | string | 是 | base64 编码的图片/文件数据（字符串） |
| fileName | string | 是 | 文件名，格式：`ImageMessage/{userId}_{timestamp}` 或 `FileMessage/{userId}_{timestamp}.{ext}` |
| isBase64 | string | 是 | 固定值 `"true"`，表示使用 base64 格式 |

**响应格式：**

```json
// 成功
{
    "url": "/ImageMessage/user123_1704067200000"
}

// 失败
{
    "error": "上传文件失败:错误信息"
}
```

**HTTP 状态码：**
- `200`: 上传成功
- `400`: 参数错误
- `500`: 服务器错误

### 2. 发送消息接口（Socket.IO）

上传成功后，需要通过 Socket.IO 发送消息：

**事件名称：** `sendMessage`

**请求参数：**
```typescript
{
    to: string,      // 目标联系人/群组 ID
    type: 'image' | 'file',  // 消息类型
    content: string  // 消息内容
}
```

**消息内容格式：**
- 图片：`{imageUrl}?width={width}&height={height}`
- 文件：`JSON.stringify({ fileUrl, filename, size, ext })`

## 实现示例

### 1. 图片上传（从相册选择）

```typescript
import * as ImagePicker from 'expo-image-picker';
import uploadFileWithProgress from '../../utils/uploadFileWithProgress';
import action from '../../state/action';

async function handleClickImage() {
    // 1. 请求相册权限
    const currentPermission = await ImagePicker.getMediaLibraryPermissionsAsync();
    if (currentPermission.accessPrivileges === 'none') {
        if (currentPermission.canAskAgain) {
            const permission = await ImagePicker.requestMediaLibraryPermissionsAsync();
            if (permission.accessPrivileges === 'none') {
                return;
            }
        } else {
            return;
        }
    }

    // 2. 选择图片（必须设置 base64: true）
    const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        base64: true,  // 重要：必须设置为 true
    });

    if (!result.cancelled) {
        // 3. 创建本地消息（显示加载状态）
        const id = addSelfMessage(
            'image',
            `${result.uri}?width=${result.width}&height=${result.height}`,
        );
        
        // 4. 上传图片（支持进度回调）
        const key = `ImageMessage/${user._id}_${Date.now()}`;
        try {
            const imageUrl = await uploadFileWithProgress(
                result.base64 as string,  // base64 字符串
                key,                       // 文件名
                (progress) => {            // 进度回调
                    // 更新消息进度（0-100）
                    action.updateSelfMessage(focus, id, {
                        percent: progress,
                    });
                },
            );
            
            // 5. 上传成功后发送消息
            sendMessage(
                id,
                'image',
                `${imageUrl}?width=${result.width}&height=${result.height}`,
            );
        } catch (err) {
            console.error(err);
            // 上传失败时删除消息
            action.deleteLinkmanMessage(focus, id);
            Toast.danger('上传图片失败');
        }
    }
}
```

### 2. 图片上传（拍照）

```typescript
async function handleClickCamera() {
    // 1. 请求相机权限
    const currentPermission = await ImagePicker.getCameraPermissionsAsync();
    if (currentPermission.status === 'undetermined') {
        if (currentPermission.canAskAgain) {
            const permission = await ImagePicker.requestCameraPermissionsAsync();
            if (permission.status === 'undetermined') {
                return;
            }
        } else {
            return;
        }
    }

    // 2. 启动相机（必须设置 base64: true）
    const result = await ImagePicker.launchCameraAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        base64: true,  // 重要：必须设置为 true
    });

    if (!result.cancelled) {
        // 3. 创建本地消息
        const id = addSelfMessage(
            'image',
            `${result.uri}?width=${result.width}&height=${result.height}`,
        );
        
        // 4. 上传图片（支持进度）
        const key = `ImageMessage/${user._id}_${Date.now()}`;
        try {
            const imageUrl = await uploadFileWithProgress(
                result.base64 as string,
                key,
                (progress) => {
                    action.updateSelfMessage(focus, id, {
                        percent: progress,
                    });
                },
            );
            
            // 5. 发送消息
            sendMessage(
                id,
                'image',
                `${imageUrl}?width=${result.width}&height=${result.height}`,
            );
        } catch (err) {
            console.error(err);
            action.deleteLinkmanMessage(focus, id);
            Toast.danger('上传图片失败');
        }
    }
}
```

### 3. 文件上传

```typescript
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system';

async function handleSendFile() {
    // 1. 选择文件
    const result = await DocumentPicker.getDocumentAsync({
        type: '*/*',  // 支持所有文件类型
    });

    if (!result.cancelled && result.type === 'success') {
        // 2. 读取文件为 base64
        const base64 = await FileSystem.readAsStringAsync(result.uri, {
            encoding: FileSystem.EncodingType.Base64,
        });

        // 3. 创建本地消息
        const id = addSelfMessage(
            'file',
            JSON.stringify({
                filename: result.name,
                size: result.size || 0,
                ext: result.name.split('.').pop()?.toLowerCase() || '',
            }),
        );

        // 4. 上传文件（支持进度）
        const key = `FileMessage/${user._id}_${Date.now()}.${result.name.split('.').pop()}`;
        try {
            const fileUrl = await uploadFileWithProgress(
                base64,
                key,
                (progress) => {
                    // 更新进度
                    action.updateSelfMessage(focus, id, {
                        percent: progress,
                    });
                },
            );

            // 5. 发送消息
            sendMessage(
                id,
                'file',
                JSON.stringify({
                    fileUrl,
                    filename: result.name,
                    size: result.size || 0,
                    ext: result.name.split('.').pop()?.toLowerCase() || '',
                }),
            );
        } catch (err) {
            console.error(err);
            action.deleteLinkmanMessage(focus, id);
            Toast.danger('上传文件失败');
        }
    }
}
```

## 核心函数说明

### uploadFileWithProgress

**位置：** `packages/app/src/utils/uploadFileWithProgress.ts`

**函数签名：**
```typescript
export default async function uploadFileWithProgress(
    base64Data: string,      // base64 编码的字符串
    fileName: string,         // 文件名
    onProgress?: (progress: number) => void,  // 进度回调，progress 范围 0-100
): Promise<string>           // 返回文件 URL
```

**实现原理：**
- 使用 `XMLHttpRequest` 发送 POST 请求
- 通过 `xhr.upload.addEventListener('progress')` 监听上传进度
- 使用 `FormData` 发送 base64 数据
- 自动获取服务器地址（从配置或本地存储）

**进度更新：**
```typescript
// 在进度回调中更新消息状态
onProgress: (progress) => {
    action.updateSelfMessage(linkmanId, messageId, {
        percent: progress,  // 0-100
    });
}
```

## 消息状态管理

### 创建消息

```typescript
function addSelfMessage(type: string, content: string) {
    const _id = focus + Date.now();
    const newMessage: Message = {
        _id,
        type,
        content,
        createTime: Date.now(),
        from: { ...user },
        to: '',
        loading: true,
        percent: type === 'image' || type === 'file' ? 0 : 100,  // 初始进度为 0
    };
    action.addLinkmanMessage(focus, newMessage);
    return _id;
}
```

### 更新进度

```typescript
// 在上传过程中更新进度
action.updateSelfMessage(linkmanId, messageId, {
    percent: progress,  // 0-100
});
```

### 更新完成状态

```typescript
// 上传成功后发送消息，服务端会返回完整消息对象
const [err, res] = await fetch('sendMessage', {
    to: linkmanId,
    type: 'image',
    content: `${imageUrl}?width=${width}&height=${height}`,
});
if (!err) {
    res.loading = false;  // 标记为完成
    res.percent = 100;    // 进度 100%
    action.updateSelfMessage(linkmanId, messageId, res);
}
```

### 删除失败消息

```typescript
// 上传失败时删除消息
action.deleteLinkmanMessage(linkmanId, messageId);
```

## 进度显示

消息组件会自动根据 `percent` 字段显示进度：

- **图片消息：** 显示圆形进度条和百分比文字
- **文件消息：** 显示 "上传中... X%" 文字

进度值范围：`0-100`，`undefined` 或 `100` 表示已完成。

## 注意事项

1. **必须设置 base64: true**
   ```typescript
   ImagePicker.launchImageLibraryAsync({
       base64: true,  // 必须设置
   });
   ```

2. **文件名格式**
   - 图片：`ImageMessage/{userId}_{timestamp}`
   - 文件：`FileMessage/{userId}_{timestamp}.{ext}`
   - 不需要文件扩展名（图片），文件需要扩展名

3. **服务器地址获取**
   - 优先从本地存储读取用户配置
   - 其次使用 `app.json` 中的 `extra.serverHost`
   - 最后使用默认值 `http://localhost:9200`

4. **错误处理**
   - 上传失败必须删除本地消息
   - 显示错误提示给用户
   - 记录错误日志

5. **进度更新频率**
   - XMLHttpRequest 会自动触发进度事件
   - 建议在回调中直接更新，不需要节流
   - 进度值会自动四舍五入到整数

6. **文件大小限制**
   - 图片：默认 5MB（可在配置中修改）
   - 文件：默认 10MB（可在配置中修改）
   - 上传前应检查文件大小

## 完整流程示例

```typescript
// 1. 选择图片
const result = await ImagePicker.launchImageLibraryAsync({
    mediaTypes: ImagePicker.MediaTypeOptions.Images,
    base64: true,
});

if (!result.cancelled) {
    // 2. 创建消息（percent: 0, loading: true）
    const messageId = addSelfMessage('image', `${result.uri}?width=${width}&height=${height}`);
    
    // 3. 上传图片（实时更新进度）
    try {
        const imageUrl = await uploadFileWithProgress(
            result.base64,
            `ImageMessage/${userId}_${Date.now()}`,
            (progress) => {
                // 更新进度：0% -> 50% -> 100%
                action.updateSelfMessage(linkmanId, messageId, { percent: progress });
            }
        );
        
        // 4. 发送消息（服务端返回完整消息，loading: false, percent: 100）
        const [err, message] = await sendMessage(linkmanId, 'image', `${imageUrl}?width=${width}&height=${height}`);
        if (!err) {
            message.loading = false;
            message.percent = 100;
            action.updateSelfMessage(linkmanId, messageId, message);
        }
    } catch (err) {
        // 5. 失败处理
        action.deleteLinkmanMessage(linkmanId, messageId);
        Toast.danger('上传失败');
    }
}
```

## 技术优势

1. **不阻塞 UI**：HTTP 上传在后台进行，UI 保持响应
2. **实时进度**：XMLHttpRequest 原生支持进度事件
3. **更好的错误处理**：HTTP 状态码和错误信息更清晰
4. **标准化**：使用标准 HTTP 协议，易于调试和维护
5. **兼容性好**：React Native 完全支持 XMLHttpRequest


